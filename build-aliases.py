#!/usr/bin/env python3
"""
Modal alias system for Zsh - Build Script (Typer CLI)

This script analyzes mode files and generates apply/rollback scripts.
It must be run in an interactive shell session to capture current alias state.
"""

import os
import re
import subprocess
from pathlib import Path
from typing import Dict
import typer

app = typer.Typer(help="Build just-aliases mode scripts.")

class AliasBuilder:
    def __init__(self):
        self.aliases_dir = Path("aliases")
        self.cache_dir = Path(".cache/just-aliases")
        self.cache_dir.mkdir(parents=True, exist_ok=True)
    
    def get_current_aliases(self) -> Dict[str, str]:
        """Get all currently defined aliases from the shell."""
        try:
            result = subprocess.run(
                ["zsh", "-c", "alias"],
                capture_output=True,
                text=True,
                check=True
            )
            
            aliases = {}
            for line in result.stdout.strip().split('\n'):
                if '=' in line:
                    # Parse alias output like: alias_name='alias_value'
                    match = re.match(r"([a-zA-Z0-9_.]+)='([^']*)'", line)
                    if match:
                        name, value = match.groups()
                        aliases[name] = value
            
            return aliases
        except subprocess.CalledProcessError:
            typer.secho("Warning: Could not get current aliases from shell", fg=typer.colors.YELLOW)
            return {}
    
    def parse_mode_file(self, mode_file: Path) -> Dict[str, str]:
        """Parse a mode file and extract alias definitions."""
        aliases = {}
        
        if not mode_file.exists():
            return aliases
        
        with open(mode_file, 'r') as f:
            for line_num, line in enumerate(f, 1):
                line = line.strip()
                
                # Skip empty lines and comments
                if not line or line.startswith('#'):
                    continue
                
                # Parse alias definition: alias name='value' or name='value'
                # Handle both forms: "alias ll='ls -la'" and "ll='ls -la'"
                if line.startswith('alias '):
                    # Remove 'alias ' prefix
                    line = line[6:]
                
                # Look for alias pattern: name='value' (including special characters like dots)
                match = re.match(r"([a-zA-Z0-9_.]+)='([^']*)'", line)
                if match:
                    name, value = match.groups()
                    aliases[name] = value
                else:
                    typer.secho(f"Warning: Could not parse alias on line {line_num}: {line}", fg=typer.colors.YELLOW)
        
        return aliases
    
    def build_mode_scripts(self, mode_name: str):
        """Build apply, rollback, and snapshot scripts for a mode."""
        mode_file = self.aliases_dir / f"{mode_name}.zsh"
        mode_aliases = self.parse_mode_file(mode_file)
        current_aliases = self.get_current_aliases()
        
        if not mode_aliases:
            typer.secho(f"Warning: No aliases found in mode '{mode_name}'", fg=typer.colors.YELLOW)
            return
        
        # Generate apply script
        apply_script = self.cache_dir / f"{mode_name}-apply.zsh"
        self._write_apply_script(apply_script, mode_aliases)
        
        # Generate snapshot and rollback scripts
        snapshot_script = self.cache_dir / f"{mode_name}-snapshot.zsh"
        rollback_script = self.cache_dir / f"{mode_name}-rollback.zsh"
        self._write_snapshot_and_rollback_scripts(
            snapshot_script, rollback_script, mode_aliases, current_aliases
        )
        
        typer.secho(f"\n‚úÖ Built scripts for mode '{mode_name}':", fg=typer.colors.GREEN, bold=True)
        typer.secho(f"  ‚Ä¢ {apply_script}", fg=typer.colors.CYAN)
        typer.secho(f"  ‚Ä¢ {rollback_script}", fg=typer.colors.CYAN)
        typer.secho(f"  ‚Ä¢ {snapshot_script}", fg=typer.colors.CYAN)
    
    def _write_apply_script(self, script_path: Path, aliases: Dict[str, str]):
        """Write the apply script that defines all aliases for a mode."""
        with open(script_path, 'w') as f:
            f.write(f"# Apply script for mode aliases\n")
            f.write(f"# Generated by build-aliases.py\n\n")
            
            for name, value in aliases.items():
                f.write(f"alias {name}='{value}'\n")
    
    def _write_snapshot_and_rollback_scripts(
        self, 
        snapshot_path: Path, 
        rollback_path: Path, 
        mode_aliases: Dict[str, str], 
        current_aliases: Dict[str, str]
    ):
        """Write snapshot and rollback scripts for a mode."""
        # Write snapshot script
        with open(snapshot_path, 'w') as f:
            f.write(f"# Snapshot of original aliases for mode\n")
            f.write(f"# Generated by build-aliases.py\n\n")
            
            for name in mode_aliases.keys():
                if name in current_aliases:
                    f.write(f"# Original alias: {name}='{current_aliases[name]}'\n")
        
        # Write rollback script
        with open(rollback_path, 'w') as f:
            f.write(f"# Rollback script for mode aliases\n")
            f.write(f"# Generated by build-aliases.py\n\n")
            
            for name in mode_aliases.keys():
                if name in current_aliases:
                    original_value = current_aliases[name]
                    f.write(f"# Check if alias '{name}' still matches mode definition\n")
                    f.write(f"if alias '{name}' 2>/dev/null | grep -q \"{name}='{original_value}'\"; then\n")
                    f.write(f"    alias {name}='{original_value}'\n")
                    f.write(f"else\n")
                    f.write(f"    # Alias '{name}' has been modified, leaving unchanged\n")
                    f.write(f"    :\n")
                    f.write(f"fi\n")
                else:
                    f.write(f"# Alias '{name}' was not defined before mode activation\n")
                    f.write(f"unalias '{name}' 2>/dev/null || true\n")
    
    def build_all_modes(self):
        """Build scripts for all available modes."""
        if not self.aliases_dir.exists():
            typer.secho("Error: aliases/ directory not found", fg=typer.colors.RED, bold=True)
            return
        
        mode_files = [f for f in self.aliases_dir.iterdir() if f.is_file() and f.suffix == ".zsh"]
        
        if not mode_files:
            typer.secho("No mode files found in aliases/ directory", fg=typer.colors.RED, bold=True)
            return
        
        typer.secho(f"\nüî® Building scripts for {len(mode_files)} modes...", fg=typer.colors.CYAN, bold=True)
        
        for mode_file in sorted(mode_files):
            # Strip .zsh extension for mode name
            mode_name = mode_file.stem
            typer.secho(f"\nüõ†Ô∏è  Processing mode: {mode_name}", fg=typer.colors.BLUE, bold=True)
            self.build_mode_scripts(mode_name)
        
        typer.secho(f"\nüéâ Build complete! Scripts written to {self.cache_dir}", fg=typer.colors.GREEN, bold=True)

builder = AliasBuilder()

@app.command()
def build():
    """Build scripts for all available modes."""
    builder.build_all_modes()

if __name__ == "__main__":
    app() 